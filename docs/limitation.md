# 约束限制

## 规格

- 磁盘：1GB+

- 内存：100MB+

- 单个请求超时时间：120s

- 单个请求Pod上限：100个

- HTTP请求并发量上限：1000QPS

## 运行时

- 每个k8s节点只能部署一个rubik，多个rubik会冲突。

- rubik不提供端口访问，只能通过sock通信。

- rubik只接收合法http请求路径及网络协议：http://localhost/（POST）、http://localhost/ping（GET）、http://localhost/version（GET）

- rubik不接受任何命令行参数，若添加参数启动会报错退出。

- 容器挂载目录时，rubik本地套接字/run/rubik的目录权限需由业务侧保证最小权限（如700）。

- 如果rubik进程进入T、D状态，则服务端不可用，此时服务不会响应任何请求。为了避免此情况的发生，请在客户端设置超时时间，避免无限等待。

## Pod优先级设置

- 禁止低优先级往高优先级切换。如业务A先被设置为低优先级（-1），接着请求设置为高优先级（0），rubik报错。

- 用户添加注解、修改注解、修改yaml中的注解并重新apply等操作不会触发Pod重建。rubik不会监控Pod注解变化情况，因此Pod的优先级和注解一致性需要kubelet及上层组件保证。

- 禁止将任务从在线组迁移到离线组后再迁移回在线组，此操作会导致该任务QoS异常。

- 禁止将重要的系统服务和内核线程加入到离线组中，否则可能导致调度不及时，进而导致系统异常。

- cpu和memory的在线、离线配置需要统一，否则可能导致两个子系统的QoS冲突。

- kubelet创建pod时需要调用rubik并确保成功，否则不保证数据一致性。

- 使用混部后，原始的cpu share功能存在限制。具体表现为：

    - 若当前cpu中同时存在在线任务和离线任务，则离线任务的cpu share无法生效。

    - 若当前cpu中只有在线任务或只有离线任务，cpu share能生效

- 用户态的优先级反转、smt、cache、numa负载均衡、离线任务的负载均衡，当前不支持。
